"""
BrainAgent – Nightly Learning Orchestrator (v3.3 – November 10, 2025)
Hot-reloads 3 files + auto-promotes winning arbitrator
Emergency retrain + full git-style history
"""

import asyncio
import logging
import json
from datetime import datetime
import pytz
from pathlib import Path

from .learner_agent import get_learner_agent
from ..candidate_tracking_service import get_candidate_tracking_service

logger = logging.getLogger(__name__)
EASTERN = pytz.timezone('US/Eastern')

class BrainAgent:
    def __init__(self):
        self.learner_agent = None
        self.tracking = None
        self.prompt_dir = Path("/workspace/bullsbears/backend/app/services/agents/prompts")
        self.history_dir = Path("/workspace/bullsbears/backend/app/services/agents/learning_history")
        self.history_dir.mkdir(exist_ok=True)

        # Emergency: <45% moon/rug capture over 30 days
        self.emergency_threshold = 0.45

    async def initialize(self):
        self.learner_agent = await get_learner_agent()
        self.tracking = await get_candidate_tracking_service()

    async def run_nightly_cycle(self):
        """4:01 AM ET – makes tomorrow's bot smarter"""
        logger.info("BrainAgent nightly cycle START")

        await self.initialize()

        retro = await self.tracking.get_30day_performance()
        if not retro.get("candidates"):
            logger.info("No data yet – skipping")
            return

        hit_rate = (retro["moon_hits"] + retro["rug_hits"]) / max(1, retro["moon_opportunities"] + retro["rug_opportunities"])
        logger.info(f"30-day hit rate: {hit_rate:.1%}")

        if hit_rate < self.emergency_threshold:
            logger.warning(f"EMERGENCY RETRAIN – hit rate {hit_rate:.1%} < 45%")

        async with self.learner_agent:
            new_prompt = await self.learner_agent.generate_finma_prompt()
            new_weights = await self.learner_agent.generate_weights()
            arbitrator_bias = await self.learner_agent.rank_arbitrators()

        # === ATOMIC HOT-RELOAD WITH BANNER ===
        await self._atomic_write(
            self.prompt_dir / "finma_prescreen_v3.txt",
            self._add_banner(new_prompt, "FinMA-7b Prescreen Prompt")
        )
        await self._atomic_write(
            self.prompt_dir / "weights.json",
            json.dumps(self._add_banner_dict(new_weights), indent=2)
        )
        await self._atomic_write(
            self.prompt_dir / "arbitrator_bias.json",
            json.dumps(self._add_banner_dict(arbitrator_bias), indent=2)
        )

        # === VERSION HISTORY ===
        ts = datetime.now(EASTERN).strftime("%Y%m%d_%H%M%S")
        await self._save_version("prompt", ts, new_prompt)
        await self._save_version("weights", ts, json.dumps(new_weights, indent=2))
        await self._save_version("bias", ts, json.dumps(arbitrator_bias, indent=2))

        logger.info(f"BrainAgent cycle COMPLETE – system upgraded for {date.today() + timedelta(days=1)}")

    def _add_banner(self, content: str, title: str) -> str:
        """Add self-documenting banner"""
        now = datetime.now(EASTERN).isoformat()
        return f"""# {'='*60}
# {title}
# AUTO-GENERATED BY BrainAgent – DO NOT EDIT MANUALLY
# Updated: {now}
# Next update: {(datetime.now(EASTERN) + timedelta(days=1)).replace(hour=4, minute=1, second=0, microsecond=0).isoformat()}
# All versions: /workspace/bullsbears/backend/app/services/agents/learning_history/
# {'='*60}

{content.strip()}
"""

    def _add_banner_dict(self, data: dict) -> dict:
        """Add banner to JSON files"""
        banner = {
            "_BRAINAGENT_AUTO_GENERATED": True,
            "_DO_NOT_EDIT_MANUALLY": "This file is overwritten nightly at 4:01 AM ET",
            "_LAST_UPDATED": datetime.now(EASTERN).isoformat(),
            "_NEXT_UPDATE": (datetime.now(EASTERN) + timedelta(days=1)).replace(hour=4, minute=1).isoformat(),
            "_HISTORY": "/workspace/bullsbears/backend/app/services/agents/learning_history/",
            "_HIT_RATE_30D": f"{await self._get_hit_rate():.1%}"  # async safe in context
        }
        return {**banner, **data}

    async def _get_hit_rate(self) -> float:
        retro = await self.tracking.get_30day_performance()
        hits = retro["moon_hits"] + retro["rug_hits"]
        total = max(1, retro["moon_opportunities"] + retro["rug_opportunities"])
        return hits / total

    async def _atomic_write(self, path: Path, content: str):
        tmp = path.with_suffix(".tmp")
        tmp.write_text(content, encoding="utf-8")
        tmp.replace(path)
        logger.info(f"Hot-reloaded → {path.name}")

    async def _save_version(self, kind: str, ts: str, content: str):
        (self.history_dir / f"{kind}_{ts}.txt").write_text(content, encoding="utf-8")

    async def should_run_emergency(self) -> bool:
        await self.initialize()
        retro = await self.tracking.get_30day_performance()
        if not retro.get("candidates"):
            return False
        rate = (retro["moon_hits"] + retro["rug_hits"]) / max(1, retro["moon_opportunities"] + retro["rug_opportunities"])
        return rate < self.emergency_threshold

# === CELERY BEAT
@celery_app.task
async def run_nightly_brain():
    async with get_brain_agent() as brain:
        await brain.run_nightly_cycle()

@celery_app.task
async def check_emergency():
    async with get_brain_agent() as brain:
        if await brain.should_run_emergency():
            await run_nightly_brain.delay()